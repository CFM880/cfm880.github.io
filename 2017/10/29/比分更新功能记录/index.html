<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>比分更新功能记录 | JsonMi</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">比分更新功能记录</h1><a id="logo" href="/.">JsonMi</a><p class="description">Android Java</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于我</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">比分更新功能记录</h1><div class="post-meta">Oct 29, 2017</div><div class="post-content"><p>最近做的比分更新功能，算是到一个完善的稳定版本了，将从以下部分由整体到具体细节一步一步实现更新比分功能，将了解到，Android的轮询实现，在长列表中如何优雅的更新局部数据，以及更新动画</p>
<ul>
<li>主体思想</li>
<li>Android服务端</li>
<li>Android客户端</li>
<li>客服端更新数据</li>
<li>重新进入应用</li>
</ul>
<p>主体思想<br>Android端定时请求list_code.htm，获取当前服务器数据更新状态标志，如果本次请求得到的code标志与上一次请求的标志不一致，则请求list.htm，实时需要更新的数据列表。<br>如下图<br><img src="http://www.cfm880.com/2017/10/29/img/服务和android更新.png" alt="主体流程"></p>
<h1 id="Android中的服务端"><a href="#Android中的服务端" class="headerlink" title="Android中的服务端"></a>Android中的服务端</h1><h2 id="服务端需要实现功能"><a href="#服务端需要实现功能" class="headerlink" title="服务端需要实现功能"></a>服务端需要实现功能</h2><ol>
<li>获得需要的参数</li>
<li>启动定时请求</li>
<li>将更新的数据传递到Activity</li>
<li>停止定时请求</li>
</ol>
<h2 id="服务端需要两个参数"><a href="#服务端需要两个参数" class="headerlink" title="服务端需要两个参数"></a>服务端需要两个参数</h2><ol>
<li>更新时间间隔</li>
<li>需要更新的赛事类别</li>
</ol>
<p>将其封装出一个CategoryServiceNeed</p>
<p>客户端每次bindService都需要将所需要的CategoryServiceNeed封装好，put到Inent中</p>
<h2 id="准备客户端需要的Binder"><a href="#准备客户端需要的Binder" class="headerlink" title="准备客户端需要的Binder"></a>准备客户端需要的Binder</h2><p>ICategoryUpdate.aidl负责获得客户端实现的IDataCallback.aidl接口，启动更新Timer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ICategoryUpdate.aidl</span><br><span class="line">package com.tango.zhibodi;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">import com.tango.zhibodi.IDataCallback;</span><br><span class="line">import com.tango.zhibodi.datasource.myentity.CategoryServiceNeed;</span><br><span class="line">interface ICategoryUpdate &#123;</span><br><span class="line">    void start();     // 设置定时器</span><br><span class="line">    void init(CategoryServiceNeed need); 重新设置更新参数</span><br><span class="line">    void setCallback(IDataCallback callback); // 设置定时器</span><br><span class="line">    void stop();      </span><br><span class="line">    void clearCallback(IDataCallback callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onServiceConnected()的是时候，将以下Binder提供给客服端调用，类似RPC调用，而在客户端实现的IDataCallback接口提供给服务端调用，从而服务端到客户端数据能双向更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">private ICategoryUpdate.Stub mBinder = new ICategoryUpdate.Stub() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(CategoryServiceNeed need) throws RemoteException &#123;</span><br><span class="line">        mNeed = need;</span><br><span class="line">        if (mNeed != null &amp;&amp;mNeed.getRefreshTime() &lt;= 0)&#123;</span><br><span class="line">            mNeed.setRefreshTime(5000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start() throws RemoteException &#123;</span><br><span class="line">        if (mNeed == null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mTimer == null)&#123;</span><br><span class="line">            mTimer = new Timer();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mTimer.cancel();</span><br><span class="line">            mTimer = null;</span><br><span class="line">            mTimer = new Timer();</span><br><span class="line">        &#125;</span><br><span class="line">        doGetData();</span><br><span class="line">        mTimer.schedule(new TimerTask() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                RetrofitHelper.getCategoryCodeService()</span><br><span class="line">                .getUpdateCodeCategory(mNeed.getCateId())</span><br><span class="line">                .enqueue(new Callback&lt;CategoryCode&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onResponse(Call&lt;CategoryCode&gt; call,</span><br><span class="line">                     Response&lt;CategoryCode&gt; response) &#123;</span><br><span class="line">                        if (!mCode.equals(response.body().getCode()))&#123;</span><br><span class="line">                           doGetData();</span><br><span class="line">                        &#125;</span><br><span class="line">                        mCode = response.body().getCode();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onFailure(Call&lt;CategoryCode&gt; call, Throwable t) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0, mNeed.getRefreshTime());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setCallback(IDataCallback callback) throws RemoteException &#123;</span><br><span class="line">        mListenerList.clear();</span><br><span class="line">        mListenerList.add(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() throws RemoteException &#123;</span><br><span class="line">        if (mTimer!= null)&#123;</span><br><span class="line">            mCode = &quot;&quot;;</span><br><span class="line">            mTimer.cancel();</span><br><span class="line">            mTimer = null;</span><br><span class="line">            mCallback = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clearCallback(IDataCallback callback) throws RemoteException &#123;</span><br><span class="line">        if (mListenerList.contains(callback))&#123;</span><br><span class="line">            mListenerList.remove(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>更新数据的列表方法，得到正确的数据后，调用iDataCallback.onSuccess()将数据传递Activity层，实现服务层到Activity层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void doGetData() &#123;</span><br><span class="line">    if (mNeed!=null) &#123;</span><br><span class="line">        RetrofitHelper.getCategoryUpdateService()</span><br><span class="line">        .getUpdateListCategory(mNeed.getCateId())</span><br><span class="line">        .enqueue(new Callback&lt;CategoryUpdateList&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call&lt;CategoryUpdateList&gt; call, </span><br><span class="line">              Response&lt;CategoryUpdateList&gt; response) &#123;</span><br><span class="line">                mCode = response.body().getCode();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (mListenerList!=null&amp;&amp;mListenerList.size()&gt;0) &#123;</span><br><span class="line">                            IDataCallback iDataCallback = mListenerList.get(0);</span><br><span class="line">                            if (iDataCallback != null)&#123;</span><br><span class="line">                                iDataCallback.onSuccess(response.body());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        DebugLogger.debug(&quot;没有是实现该接口&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call&lt;CategoryUpdateList&gt; call, Throwable t) &#123;</span><br><span class="line">                    if (mListenerList!=null&amp;&amp;mListenerList.size()&gt;0) &#123;</span><br><span class="line">                    	IDataCallback iDataCallback = mListenerList.get(0);</span><br><span class="line">                    if (iDataCallback != null)&#123;</span><br><span class="line">                        iDataCallback.onFailed(&quot;请求失败&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    DebugLogger.debug(&quot;没有是实现该接口&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note: 为什么在Serive使用异步，不是使用同步，因为，Serivce也是和Activity都是属于Appliction下的，是Appliction的组件，所以也不能使用做耗时的请求。参见深入理解Android源码第二章</p>
<p>自此我们完成了获取参数，启动更新，数据更新到Acivity层，还差停止定时请求，这个放在Service的onUnbind生命方法中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当unbind的时候需要将初始化的变量清除</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public boolean onUnbind(Intent intent) &#123;</span><br><span class="line">    mNeed = null;</span><br><span class="line">    if (mTimer!= null)&#123;</span><br><span class="line">        mCode = &quot;&quot;;</span><br><span class="line">        mTimer.cancel();</span><br><span class="line">        mTimer = null;</span><br><span class="line">        mCallback = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onUnbind(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Android中的客户端<br>客户端实现的功能就比较简单了，需要</p>
<ol>
<li>绑定服务</li>
<li>实现IDataCallback</li>
<li>取消绑定服务</li>
</ol>
<p>在客户端中主要是Fragment绑定服务，和解除绑定，这两个动作需要与Fragment的生命周期一致并且得配对好，所以我就选择在onResume()绑定服务和onPause()中解除绑定。进入下一个Acitvity还是退出Activity必调用onPasue()，而从Activity回来也必调onResume()</p>
<p>绑定服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onResume() &#123;</span><br><span class="line">    super.onResume();</span><br><span class="line">    HomeCate homeCateByIndex = </span><br><span class="line">       mAdapter.getHomeCateByIndex(viewPager.getCurrentItem());</span><br><span class="line">    if (homeCateByIndex != null) &#123;</span><br><span class="line">        bindToService(homeCateByIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void bindToService(HomeCate homeCate) &#123;</span><br><span class="line">    Intent intent = new Intent(getActivity(), CategoryUpdateService.class);</span><br><span class="line">    CategoryServiceNeed need = new CategoryServiceNeed();</span><br><span class="line">    need.setRefreshTime(homeCate.getRefreshtime() * 1000);</span><br><span class="line">    need.setCateId(homeCate.getCateid());</span><br><span class="line">    intent.putExtra(CATEGORY_NEED, need);</span><br><span class="line">    getActivity().bindService(intent, mConnection, Activity.BIND_AUTO_CREATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现IDataCallback接口，在onSuccess()方法中只需要数据包裹在Message中，然后交给Handler把数据添加到MessageQuene中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static IDataCallback.Stub mCallback = new IDataCallback.Stub() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSuccess(CategoryUpdateList list) throws RemoteException &#123;</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.what = 0x1000;</span><br><span class="line">        Bundle bundle = new Bundle();</span><br><span class="line">        bundle.putParcelable(&quot;Update&quot;, list);</span><br><span class="line">        message.setData(bundle);</span><br><span class="line">        mUpdateUI.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFailed(String msg) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将mConnection传到bindService方法中，一旦建立连接后，设置回调接口，启动更新（之前，不晓得RPC这个概念，这就相当于在客户端调用了服务端的方法，很给力）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 连接</span><br><span class="line"> */</span><br><span class="line">private ServiceConnection mConnection = new ServiceConnection() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">        mCategoryUpdate = ICategoryUpdate.Stub.asInterface(service);</span><br><span class="line">        try &#123;</span><br><span class="line">        	  mCategoryUpdate.setCallback(mCallback);</span><br><span class="line">            mCategoryUpdate.start();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mCategoryUpdate.clearCallback(mCallback);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解除绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onPause() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (mCategoryUpdate != null) &#123;</span><br><span class="line">            if (mCategoryUpdate.asBinder().isBinderAlive()) &#123;</span><br><span class="line">                getActivity().unbindService(mConnection);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    super.onPause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note: 为啥要加try catch捕获crash异常，及时是配对的bind和unbind，但是极少数情况下，就给你来个给个服务之前已经取消绑定了，不要再给我取消绑定，再给取消绑定，我崩给你看。</p>
<h1 id="数据更新UI部分"><a href="#数据更新UI部分" class="headerlink" title="数据更新UI部分"></a>数据更新UI部分</h1><p>终于到高潮了，马上就能看到UI更新的效果。好激动，还是先冷静一下，看看有哪几类客户端</p>
<ol>
<li>ViewPager Container类Fragment.</li>
<li>头部比分类Fragment</li>
</ol>
<h2 id="ViewPager-Container类Fragment"><a href="#ViewPager-Container类Fragment" class="headerlink" title="ViewPager Container类Fragment"></a>ViewPager Container类Fragment</h2><p>我们这类app都是采用TabLayout+ViewPager来实现，所以我就选在TabLayout+ViewPager的Fragment作为客户端，而不是选择ViewPager中具体的Fragment来作为客户端<br>这样做的好处</p>
<ol>
<li>避免了频繁的绑定，解除绑定</li>
<li>统一管理更新</li>
</ol>
<p>这里里面涉及到，怎么调用ViewPager下的Fragment的更新方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static class UiUpdateHandler extends Handler &#123;</span><br><span class="line">    SoftReference&lt;HomeFragment&gt; mFragmentReference;</span><br><span class="line">    UiUpdateHandler(SoftReference&lt;HomeFragment&gt; fragmentReference) &#123;</span><br><span class="line">        mFragmentReference = fragmentReference;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        super.handleMessage(msg);</span><br><span class="line">        if (msg.what == 0x1000) &#123;</span><br><span class="line">            HomeFragment fragment = mFragmentReference.get();</span><br><span class="line">            CategoryUpdateList list = msg.getData().getParcelable(&quot;Update&quot;);</span><br><span class="line">            if (fragment != null) &#123;</span><br><span class="line">                if (list != null &amp;&amp; list.getList() != null &amp;&amp;</span><br><span class="line">                list.getList().size() &gt; 0) &#123;</span><br><span class="line">                    Fragment item = fragment.adapter.getCurrentFragment();</span><br><span class="line">                    if (item instanceof CateHomeHotFragment) &#123;</span><br><span class="line">                        ((CateHomeHotFragment) item).update(list);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (item instanceof CateHomeFragment) &#123;</span><br><span class="line">                        ((CateHomeFragment) item).update(list);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我值ViewPager的Adapter中添加了getCurrentFragment()获取当前页的Fragment, 这个方法会被具体的Fragment向上转型成通用的Fragment，之后调用updata()方法更新，当然也可把CateHomeHotFragment和CateHomeHotFragment重构成一个抽象类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public Fragment getCurrentFragment() &#123;</span><br><span class="line">    return mCurrentFragment;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void setPrimaryItem(ViewGroup container, </span><br><span class="line">int position, Object object) &#123;</span><br><span class="line">    if (getCurrentFragment() != object) &#123;</span><br><span class="line">        mCurrentFragment = ((Fragment) object);</span><br><span class="line">    &#125;</span><br><span class="line">    super.setPrimaryItem(container, position, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fragment调用的update方法，mGameRVAdapter.updateVisibleItem(mLiveIndex, first, last, list);<br>mLiveIndex记录第一个在直播中的位置，之后如果下拉加载之前的数据，需要mLiveIndex += 封装后的List的长度。<br>first列表中当前第一个可见的item的位置，last列表中当前最后一个可见的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 刷新列表</span><br><span class="line"> * @param list</span><br><span class="line"> */</span><br><span class="line">public void update(CategoryUpdateList list) &#123;</span><br><span class="line">    if (mGameRVAdapter!=null)&#123;</span><br><span class="line">        if (mRecyclerView.getScrollState() == </span><br><span class="line">        RecyclerView.SCROLL_STATE_IDLE) &#123;</span><br><span class="line">            int first = </span><br><span class="line">            linearLayoutManager.findFirstVisibleItemPosition();</span><br><span class="line">            int last = </span><br><span class="line">            linearLayoutManager.findLastVisibleItemPosition();</span><br><span class="line">            mGameRVAdapter.updateVisibleItem(mLiveIndex, first, last, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在Adapter中更新的需要从mLiveIndex向下找的第一个是日期类型的item，通过id匹配，最后更新数据，但是notifyItemChanged的只有[first,last]中匹配的id<br>Note:直接调notifyItemChanged(postion)会使图片闪烁，所以需要用notifyItemChanged(postion， Object)和以下方法配合使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBindViewHolder(final BaseViewHolder holder, </span><br><span class="line">final int position, List playList) &#123;</span><br><span class="line">    if (playList.isEmpty())&#123;</span><br><span class="line">        onBindViewHolder(holder, position);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        holder.bindingData(mList.get(position), context, isNoScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此ViewPager Container类Fragment完成数据更新</p>
<h2 id="头部比分类Fragment"><a href="#头部比分类Fragment" class="headerlink" title="头部比分类Fragment"></a>头部比分类Fragment</h2><p>这类的客户端就简单多了，分成两类</p>
<ol>
<li>带小小比分的Fragment</li>
<li>不带小小比分的Fragment</li>
<li>不带局数的Fragment;</li>
</ol>
<h3 id="抽取公共方法"><a href="#抽取公共方法" class="headerlink" title="抽取公共方法"></a>抽取公共方法</h3><p>开始编写这个公能的时候，我将这个三个类都单独的，绑定服务，解除绑定，更新数据<br>但是绑定服务，解除绑定，不同就是更新数据的部分不同，这时候抽象类的功效就来了，绑定服务，解除绑定，初始化的一些数据全部放到，抽象类中<br>添加更新头部比分和小比分的抽象方法，在子类中初始化UI控件，将更新的数据类上ViewPager Container类Fragment完成数据更新，只不过这次<br>只需要遍历列表，找到比赛id，实现对应的部比分和小比分的抽象方法即可</p>
<h3 id="RecyclerView更新动画"><a href="#RecyclerView更新动画" class="headerlink" title="RecyclerView更新动画"></a>RecyclerView更新动画</h3><p>由于每次跟新数据，RecycelerView渐变动画，时间太短，我们需要设置Recycler的渐变动画<br>在RecyclerView如果没有设置动画，Recyceler设置一个默认250ms的渐变动画，这个动画对于用户来说，TMD什么时候变的，我都没看清楚就变了，<br>这时候，重新设置一下recyclerView的渐变动画时间即可，当然也可以重写SimpleItemAnimator实现自己的数据更新动画，在Adapter的 onAttachedToRecyclerView中设置动画时间为3秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123;</span><br><span class="line">    super.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">    mSetsRV = recyclerView;</span><br><span class="line">    DefaultItemAnimator defaultItemAnimator = new DefaultItemAnimator();</span><br><span class="line">    defaultItemAnimator.setAddDuration(DURATION);</span><br><span class="line">    defaultItemAnimator.setChangeDuration(DURATION);</span><br><span class="line">    defaultItemAnimator.setMoveDuration(DURATION);</span><br><span class="line">    defaultItemAnimator.setRemoveDuration(DURATION);</span><br><span class="line">    mSetsRV.setItemAnimator(defaultItemAnimator);</span><br><span class="line">    mContext = recyclerView.getContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个客户端都完成数据跟新了，看看最终结果吧</p>
<p><img src="http://www.cfm880.com/2017/10/29/img/Screenshot_20171029-194902.png" height="400" alt="首页"><br><img src="http://www.cfm880.com/2017/10/29/img/Screenshot_20171029-195012.png" height="400" alt="详情页"> </p>
<h1 id="重新进入应用处理"><a href="#重新进入应用处理" class="headerlink" title="重新进入应用处理"></a>重新进入应用处理</h1><p>我们这服务并不需要包活，app没处于活动状态，没有比要跟新比分，费流量<br>冲新进入应用，需要走SplashActivity–&gt;到MainActivity.onRestart()方法<br>所以在重写的onRestart()方法中findFragmentByTag(“Tab1”)，在调用fragment方法即可</p>
<p>MainAcitvity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onRestart() &#123;</span><br><span class="line">    super.onRestart();</span><br><span class="line">    Fragment tab1 = getSupportFragmentManager().findFragmentByTag(&quot;Tab1&quot;);</span><br><span class="line">    if (tab1!=null &amp;&amp; tab1 instanceof HomeFragment)&#123;</span><br><span class="line">        HomeFragment home = (HomeFragment) tab1;</span><br><span class="line">        home.onRestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HomFragment，绑定以一下服务或者启动一下更新，就Over了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void onRestart() &#123;</span><br><span class="line">    if (homeSoftReference == null)&#123;</span><br><span class="line">        homeSoftReference = new SoftReference&lt;&gt;(this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mUpdateUI == null)&#123;</span><br><span class="line">        mUpdateUI = new UiUpdateHandler(homeSoftReference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (!mCategoryUpdate.asBinder().isBinderAlive()) &#123;</span><br><span class="line">            HomeCate homeCateByIndex = </span><br><span class="line">            adapter.getHomeCateByIndex(viewPager.getCurrentItem());</span><br><span class="line">            bindToService(homeCateByIndex);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mCategoryUpdate.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/Android/">Android</a></div><div class="post-nav"><a class="pre" href="/2017/11/10/Android消息机制/">Android消息机制</a><a class="next" href="/2017/09/10/Handler使用的使用/">Handler使用，内存泄漏的前前后后</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android系统/">Android系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/VLC/" style="font-size: 15px;">VLC</a> <a href="/tags/月记/" style="font-size: 15px;">月记</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Android原理/" style="font-size: 15px;">Android原理</a> <a href="/tags/硬件/" style="font-size: 15px;">硬件</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/嵌入式/" style="font-size: 15px;">嵌入式</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Ionic/" style="font-size: 15px;">Ionic</a> <a href="/tags/Context/" style="font-size: 15px;">Context</a> <a href="/tags/折腾/" style="font-size: 15px;">折腾</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/flex/" style="font-size: 15px;">flex</a> <a href="/tags/感悟/" style="font-size: 15px;">感悟</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/旅行/" style="font-size: 15px;">旅行</a> <a href="/tags/插件化/" style="font-size: 15px;">插件化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/19/旅行/201810川西一路/">川西一路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/插件化/01预备知识/插件化技术的发展/">插件化技术的发展</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/Android校时全过程/">Android 校时全过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/03/IoT_deploy/">IoT部署相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/16/年末了/">年末了</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/13/事件分发机制/">事件分发机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/Android消息机制/">Android消息机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/比分更新功能记录/">比分更新功能记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Handler使用的使用/">Handler使用，内存泄漏的前前后后</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/常用的git命令/">常用的git命令</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">JsonMi.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>