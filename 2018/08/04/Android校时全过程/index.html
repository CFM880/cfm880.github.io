<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android 校时全过程 | JsonMi</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android 校时全过程</h1><a id="logo" href="/.">JsonMi</a><p class="description">Android Java</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于我</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android 校时全过程</h1><div class="post-meta">Aug 4, 2018</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#相关类图"><span class="toc-number">1.</span> <span class="toc-text">相关类图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#系统设置"><span class="toc-number">1.1.</span> <span class="toc-text">系统设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统校时"><span class="toc-number">1.2.</span> <span class="toc-text">系统校时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统设置与时间相关部分"><span class="toc-number">2.</span> <span class="toc-text">系统设置与时间相关部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设置时间"><span class="toc-number">2.1.</span> <span class="toc-text">设置时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动校时设置"><span class="toc-number">2.2.</span> <span class="toc-text">自动校时设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统校时部分"><span class="toc-number">3.</span> <span class="toc-text">系统校时部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ServerManager与校时相关的"><span class="toc-number">3.1.</span> <span class="toc-text">ServerManager与校时相关的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NetworkTimeUpdateService"><span class="toc-number">3.2.</span> <span class="toc-text">NetworkTimeUpdateService</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NetworkTimeUpdateService初始化"><span class="toc-number">3.2.1.</span> <span class="toc-text">NetworkTimeUpdateService初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#校时轮询"><span class="toc-number">3.2.2.</span> <span class="toc-text">校时轮询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行逻辑"><span class="toc-number">3.2.3.</span> <span class="toc-text">执行逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统校时总结"><span class="toc-number">3.3.</span> <span class="toc-text">系统校时总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对于我们app来说应该怎么弄"><span class="toc-number">4.</span> <span class="toc-text">对于我们app来说应该怎么弄</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设置时间目前我们有4种方式"><span class="toc-number">4.1.</span> <span class="toc-text">设置时间目前我们有4种方式</span></a></li></ol></li></ol></div></div><div class="post-content"><p>对于一个Launcher来说，时间基准是最为重要的，特别是我们这种没有系统顶部的通知栏的app，而且会经常断电重启的Android机器，Android自带的校时，由于某些原因，校时比较慢，需要在app上加上一个校时才能保证在有网的情况下第一时间校时。<br><a id="more"></a></p>
<p>在某些场景下，校时还是比较重要的例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.直播课的开始时间</span><br><span class="line">2.课程表的定位</span><br><span class="line">3.今天明天（这种对用户友好的日期方式）</span><br></pre></td></tr></table></figure></p>
<h2 id="相关类图"><a href="#相关类图" class="headerlink" title="相关类图"></a>相关类图</h2><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><p><img src="https://wx3.sinaimg.cn/mw1024/c2ab4ab1ly1fxcmb61uhej21bo0pgdiq.jpg" alt="系统设置"></p>
<h3 id="系统校时"><a href="#系统校时" class="headerlink" title="系统校时"></a>系统校时</h3><p><img src="https://wx3.sinaimg.cn/mw1024/c2ab4ab1ly1fxcmb6ljwkj21w01o4n70.jpg" alt="系统校时"></p>
<p>既然是校时，我先了解一下系统是怎么个校时流程，然后再动手写自己的校时</p>
<h2 id="系统设置与时间相关部分"><a href="#系统设置与时间相关部分" class="headerlink" title="系统设置与时间相关部分"></a>系统设置与时间相关部分</h2><p>在Android系统自带的设置中有设置时间的功能，从这里出发是最好的</p>
<h3 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h3><p>Settings里包含所有Activity, 这里面所有的Activity又继承SettingsActivity;<br>在SettingsActivity里ENTRY_FRAGMENTS里全是Fragment的类名，可想而知Settings App里基本都是有Fragment组成，在这里面，DateTimeSettings.class.getName()，尤为耀眼，这不是我要找的么，至于，怎么把这个Fragment加载到Settings里，现在重点不在这。</p>
<p>SettingsFragment实现了TimePickerDialog.OnTimeSetListener, DatePickerDialog.OnDateSetListener<br>这两个就是设置时间和日期的回调。</p>
<p>在onResume()里添加了时间改变的接收器，接收器了更新相关时间的UI<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Register for time ticks and other reasons for time change</span><br><span class="line">IntentFilter filter = new IntentFilter();</span><br><span class="line">filter.addAction(Intent.ACTION_TIME_TICK);</span><br><span class="line">filter.addAction(Intent.ACTION_TIME_CHANGED);</span><br><span class="line">filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);</span><br><span class="line">getActivity().registerReceiver(mIntentReceiver, filter, null, null);</span><br></pre></td></tr></table></figure></p>
<p>在onTimeSet和onDateSet里分别将设置好的时间封装进一个Calender里最后调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((AlarmManager) context.getSystemService(Context.ALARM_SERVICE)).setTime(when);</span><br></pre></td></tr></table></figure></p>
<p>然后mIntentReceiver会接收时间改变的广播，更UI</p>
<h3 id="自动校时设置"><a href="#自动校时设置" class="headerlink" title="自动校时设置"></a>自动校时设置</h3><p>这是我们后面app校时的一种方式，估计没人发现并用起来<br>设置自动校时在OnSharedPreferenceChangeListener的回调中完成的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onSharedPreferenceChanged(SharedPreferences preferences, String key) &#123;</span><br><span class="line">    if (key.equals(KEY_AUTO_TIME)) &#123;</span><br><span class="line">        boolean autoEnabled = preferences.getBoolean(key, true);</span><br><span class="line">        Settings.Global.putInt(getContentResolver(), Settings.Global.AUTO_TIME,</span><br><span class="line">                autoEnabled ? 1 : 0);</span><br><span class="line">        mTimePref.setEnabled(!autoEnabled);</span><br><span class="line">        mDatePref.setEnabled(!autoEnabled);</span><br><span class="line">    &#125; else if (key.equals(KEY_AUTO_TIME_ZONE)) &#123;</span><br><span class="line">        boolean autoZoneEnabled = preferences.getBoolean(key, true);</span><br><span class="line">        Settings.Global.putInt(</span><br><span class="line">                getContentResolver(), Settings.Global.AUTO_TIME_ZONE, autoZoneEnabled ? 1 : 0);</span><br><span class="line">        mTimeZone.setEnabled(!autoZoneEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们后面也可来个轮询设置自动校时，相当于调用系统自带的校时api校时，但是这种也是需要系统app的权限才可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_SECURE_SETTINGS&quot;/&gt;</span><br><span class="line">Settings.Global.putInt(</span><br><span class="line">                getContentResolver(), Settings.Global.AUTO_TIME_ZONE, autoZoneEnabled ? 1 : 0);</span><br></pre></td></tr></table></figure></p>
<p>这是设置这条线走完</p>
<h2 id="系统校时部分"><a href="#系统校时部分" class="headerlink" title="系统校时部分"></a>系统校时部分</h2><h3 id="ServerManager与校时相关的"><a href="#ServerManager与校时相关的" class="headerlink" title="ServerManager与校时相关的"></a>ServerManager与校时相关的</h3><p>Android的系统服务都是在Framework中的ServerManager中启动的<br>其中startOtherServices()负责我们所关注的NetworkTimeUpdateService的创建和运行;</p>
<p>ServerManager中的与NetworkTimeUpdateService相关的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">    ...</span><br><span class="line">    NetworkTimeUpdateService networkTimeUpdater = null;</span><br><span class="line">    ...</span><br><span class="line">    if (!disableNetwork &amp;&amp; !disableNetworkTime) &#123;    // line 904</span><br><span class="line">        try &#123;</span><br><span class="line">            Slog.i(TAG, &quot;NetworkTimeUpdateService&quot;);</span><br><span class="line">            networkTimeUpdater = new NetworkTimeUpdateService(context);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            reportWtf(&quot;starting NetworkTimeUpdate service&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater; //line 1080</span><br><span class="line">    ...</span><br><span class="line">    // We now tell the activity manager it is okay to run third party</span><br><span class="line">    // code.  It will call back into us once it has gotten to the state</span><br><span class="line">    // where third party code can really run (but before it has actually</span><br><span class="line">    // started launching the initial applications), for us to complete our</span><br><span class="line">    // initialization.</span><br><span class="line">    mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                ...</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (networkTimeUpdaterF != null) networkTimeUpdaterF.systemRunning(); // line 1174</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying NetworkTimeService running&quot;, e);</span><br><span class="line">                &#125; </span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在startOtherServices中初始化了NetworkTimeUpdateService, 然后调用NetworkTimeUpdateService#systemRunning()</p>
<h3 id="NetworkTimeUpdateService"><a href="#NetworkTimeUpdateService" class="headerlink" title="NetworkTimeUpdateService"></a>NetworkTimeUpdateService</h3><h4 id="NetworkTimeUpdateService初始化"><a href="#NetworkTimeUpdateService初始化" class="headerlink" title="NetworkTimeUpdateService初始化"></a>NetworkTimeUpdateService初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public NetworkTimeUpdateService(Context context) &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    // 获得mCachedNtpTime</span><br><span class="line">    mTime = NtpTrustedTime.getInstance(context);</span><br><span class="line">    // 定时触发广播</span><br><span class="line">    mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">    Intent pollIntent = new Intent(ACTION_POLL, null);</span><br><span class="line">    // resetAlarm()递归用的</span><br><span class="line">    mPendingPollIntent = PendingIntent.getBroadcast(mContext, POLL_REQUEST, pollIntent, 0);</span><br><span class="line"></span><br><span class="line">    mPollingIntervalMs = mContext.getResources().getInteger(</span><br><span class="line">            com.android.internal.R.integer.config_ntpPollingInterval);</span><br><span class="line">    mPollingIntervalShorterMs = mContext.getResources().getInteger(</span><br><span class="line">            com.android.internal.R.integer.config_ntpPollingIntervalShorter);</span><br><span class="line">    mTryAgainTimesMax = mContext.getResources().getInteger(</span><br><span class="line">            com.android.internal.R.integer.config_ntpRetry);</span><br><span class="line">    mTimeErrorThresholdMs = mContext.getResources().getInteger(</span><br><span class="line">            com.android.internal.R.integer.config_ntpThreshold);</span><br><span class="line"></span><br><span class="line">    mWakeLock = ((PowerManager) context.getSystemService(Context.POWER_SERVICE)).newWakeLock(</span><br><span class="line">            PowerManager.PARTIAL_WAKE_LOCK, TAG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册广播接收器，初始化Handler，开始校时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/** Initialize the receivers and initiate the first NTP request */</span><br><span class="line">public void systemRunning() &#123;</span><br><span class="line">    // 时间变化后，缓存上次的时间</span><br><span class="line">    registerForTelephonyIntents();</span><br><span class="line">    // 定时接收广播</span><br><span class="line">    registerForAlarms();</span><br><span class="line">    // 网络变化时，发送消息到 mHandler,发送消息</span><br><span class="line">    registerForConnectivityIntents();</span><br><span class="line"></span><br><span class="line">    HandlerThread thread = new HandlerThread(TAG);</span><br><span class="line">    thread.start();</span><br><span class="line">    mHandler = new MyHandler(thread.getLooper());</span><br><span class="line">    // Check the network time on the new thread</span><br><span class="line">    mHandler.obtainMessage(EVENT_POLL_NETWORK_TIME).sendToTarget();</span><br><span class="line"></span><br><span class="line">    mSettingsObserver = new SettingsObserver(mHandler, EVENT_AUTO_TIME_CHANGED);</span><br><span class="line">    mSettingsObserver.observe(mContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="校时轮询"><a href="#校时轮询" class="headerlink" title="校时轮询"></a>校时轮询</h4><p>处理状态变化后的时间轮询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/** Handler to do the network accesses on */</span><br><span class="line">private class MyHandler extends Handler &#123;</span><br><span class="line"></span><br><span class="line">    public MyHandler(Looper l) &#123;</span><br><span class="line">        super(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case EVENT_AUTO_TIME_CHANGED:</span><br><span class="line">            case EVENT_POLL_NETWORK_TIME:</span><br><span class="line">            case EVENT_NETWORK_CHANGED:</span><br><span class="line">                onPollNetworkTime(msg.what);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void onPollNetworkTime(int event) &#123;</span><br><span class="line">    // If Automatic time is not set, don&apos;t bother.</span><br><span class="line">    if (!isAutomaticTimeRequested()) return;</span><br><span class="line">    mWakeLock.acquire();</span><br><span class="line">    try &#123;</span><br><span class="line">        onPollNetworkTimeUnderWakeLock(event);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mWakeLock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onPollNetworkTimeUnderWakeLock这是校时的内心代码了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void onPollNetworkTimeUnderWakeLock(int event) &#123;</span><br><span class="line">    final long refTime = SystemClock.elapsedRealtime();</span><br><span class="line">    // If NITZ time was received less than mPollingIntervalMs time ago,</span><br><span class="line">    // no need to sync to NTP.</span><br><span class="line">    if (mNitzTimeSetTime != NOT_SET &amp;&amp; refTime - mNitzTimeSetTime &lt; mPollingIntervalMs) &#123;</span><br><span class="line">        resetAlarm(mPollingIntervalMs);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    final long currentTime = System.currentTimeMillis();</span><br><span class="line">    if (DBG) Log.d(TAG, &quot;System time = &quot; + currentTime);</span><br><span class="line">    // Get the NTP time</span><br><span class="line">    if (mLastNtpFetchTime == NOT_SET || refTime &gt;= mLastNtpFetchTime + mPollingIntervalMs</span><br><span class="line">            || event == EVENT_AUTO_TIME_CHANGED) &#123;</span><br><span class="line">        if (DBG) Log.d(TAG, &quot;Before Ntp fetch&quot;);</span><br><span class="line"></span><br><span class="line">        // force refresh NTP cache when outdated</span><br><span class="line">        if (mTime.getCacheAge() &gt;= mPollingIntervalMs) &#123;</span><br><span class="line">            mTime.forceRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // only update when NTP time is fresh</span><br><span class="line">        if (mTime.getCacheAge() &lt; mPollingIntervalMs) &#123;</span><br><span class="line">            final long ntp = mTime.currentTimeMillis();</span><br><span class="line">            mTryAgainCounter = 0;</span><br><span class="line">            // If the clock is more than N seconds off or this is the first time it&apos;s been</span><br><span class="line">            // fetched since boot, set the current time.</span><br><span class="line">            if (Math.abs(ntp - currentTime) &gt; mTimeErrorThresholdMs</span><br><span class="line">                    || mLastNtpFetchTime == NOT_SET) &#123;</span><br><span class="line">                // Set the system time</span><br><span class="line">                if (DBG &amp;&amp; mLastNtpFetchTime == NOT_SET</span><br><span class="line">                        &amp;&amp; Math.abs(ntp - currentTime) &lt;= mTimeErrorThresholdMs) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;For initial setup, rtc = &quot; + currentTime);</span><br><span class="line">                &#125;</span><br><span class="line">                if (DBG) Log.d(TAG, &quot;Ntp time to be set = &quot; + ntp);</span><br><span class="line">                // Make sure we don&apos;t overflow, since it&apos;s going to be converted to an int</span><br><span class="line">                if (ntp / 1000 &lt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                    SystemClock.setCurrentTimeMillis(ntp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (DBG) Log.d(TAG, &quot;Ntp time is close enough = &quot; + ntp);</span><br><span class="line">            &#125;</span><br><span class="line">            mLastNtpFetchTime = SystemClock.elapsedRealtime();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Try again shortly</span><br><span class="line">            mTryAgainCounter++;</span><br><span class="line">            if (mTryAgainTimesMax &lt; 0 || mTryAgainCounter &lt;= mTryAgainTimesMax) &#123;</span><br><span class="line">                resetAlarm(mPollingIntervalShorterMs);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Try much later</span><br><span class="line">                mTryAgainCounter = 0;</span><br><span class="line">                resetAlarm(mPollingIntervalMs);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resetAlarm(mPollingIntervalMs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a>执行逻辑</h4><p>如果已经设置过了，并且和前一次设置的时间小于轮询时间，<br>    下一个轮询时间后再来看，<br>如果上次刷新时间和调用此方法的时间差大于了轮询时间，<br>    说明上次轮询超时，强制更新。<br>没有设置时间||当前启动时间大于上次轮询时间+轮询间隔，或者用户改变了自动校时<br>    上次tcp请求到调用getCacheAge()之间的时间间隔&gt;轮询的时间间隔<br>        直接强制更新<br>    小于的是时候<br>        ntp 获得时间和当前时间大于容错时间的时候||或者时间没设置的时候<br>        设置时间<br>        同时页跳出了一只定时轮询的循环<br>    剩下的是每次都会执行<br>        重试次数++;<br>        检验时间计数<br>        有没有超过最大重试次数的时候<br>            轮询时间设置短点<br>        超过了<br>            重置重试次数<br>        并且请下次轮询时间增大<br>都有没满足，下次再说</p>
<h3 id="系统校时总结"><a href="#系统校时总结" class="headerlink" title="系统校时总结"></a>系统校时总结</h3><p>写法的巧妙之处<br>在于，两个不同的轮询间隔mPollingIntervalShorterMs和mPollingIntervalMs<br>第一次，强制更新后但并不会设置时间，而是等到mPollingIntervalShorterMs下次拿设置时间，<br>而下次来设置时间的时候，一般网络情况较好的时候，是能把时间获取得到<br>将时间保存在mTime中的mCachedNtpTime中，同时记录了获取时间时的开机时间</p>
<p>下次调用的时候，mTime.getCacheAge()基本都会小于mPollingIntervalMs<br>这是时候就可以得到ntp时间了(mTime.currentTimeMillis();)这个时间是由上次ntp获取的时间+当前开机时间-上次获取ntp时间时的开机时间<br>再判断断一下是否需要设置时间。<br>这是后就跳出轮询了。</p>
<p>没有满足条件就会resetAlarm(),在mPollingIntervalMs后在registerForAlarms注册的广播，<br>发送消息到MyHandler, 最后还是到onPollNetworkTimeUnderWakeLock<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void registerForAlarms() &#123;</span><br><span class="line">    mContext.registerReceiver(</span><br><span class="line">        new BroadcastReceiver() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">                mHandler.obtainMessage(EVENT_POLL_NETWORK_TIME).sendToTarget();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, new IntentFilter(ACTION_POLL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Cancel old alarm and starts a new one for the specified interval.</span><br><span class="line">*</span><br><span class="line">* @param interval when to trigger the alarm, starting from now.</span><br><span class="line">*/</span><br><span class="line">private void resetAlarm(long interval) &#123;</span><br><span class="line">    mAlarmManager.cancel(mPendingPollIntent);</span><br><span class="line">    long now = SystemClock.elapsedRealtime();</span><br><span class="line">    long next = now + interval;</span><br><span class="line">    mAlarmManager.set(AlarmManager.ELAPSED_REALTIME, next, mPendingPollIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对于我们app来说应该怎么弄"><a href="#对于我们app来说应该怎么弄" class="headerlink" title="对于我们app来说应该怎么弄"></a>对于我们app来说应该怎么弄</h2><h3 id="设置时间目前我们有4种方式"><a href="#设置时间目前我们有4种方式" class="headerlink" title="设置时间目前我们有4种方式"></a>设置时间目前我们有4种方式</h3><p>SystemClock.setCurrentTimeMillis(ntp);<br>((AlarmManager) context.getSystemService(Context.ALARM_SERVICE)).setTime(when);<br>用shell命令来弄<br>轮询的方式设置为自动校时（这是方式还没试过，完全依赖系统还是比较靠谱的）<br>Settings.Global.putInt(getContentResolver(), Settings.Global.AUTO_TIME_ZONE, 1);<br>需要在mainfest.xml添加写入系统设置的权限（这个很没节操）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--写系统设置校时用的设置为自动校时--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_SECURE_SETTINGS&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_SECURE_SETTINGS&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>1, 2 两种需要系统签名，而3.三种需要有root权限。如果这两种都没有，抱歉臣妾做不到<br>还有一种是轮询设置自动校时，这种不道德，但是也是被逼的😆</p>
<p>我们的app没有系统签名，有root权限，比较奇葩</p>
<p>第4种是需要系统级app的权限。</p>
<p>校时的实现<br>当然我们这种网络校时有中不好的情况，<br>就是我们的校时先于系统的校时，这时候会触发两次时间改变的广播</p>
<p>时间改变后，重新提交一下fragment（简单粗暴我喜欢）</p>
<p>校时的services;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class SyncTimeService extends Service &#123;</span><br><span class="line">    private static final String TAG = SyncTimeService.class.getSimpleName();</span><br><span class="line">    private Timer mTimer;</span><br><span class="line">    public SyncTimeService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        // TODO: Return the communication channel to the service.</span><br><span class="line">        throw new UnsupportedOperationException(&quot;Not yet implemented&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line"></span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        if (mTimer == null)&#123;</span><br><span class="line">            mTimer = new Timer();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mTimer.cancel();</span><br><span class="line">            mTimer = null;</span><br><span class="line">            mTimer = new Timer();</span><br><span class="line">        &#125;</span><br><span class="line">        mTimer.schedule(new TimerTask() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    URLConnection uc = new URL(&quot;http://www.baidu.com&quot;).openConnection();</span><br><span class="line">                    uc.connect();</span><br><span class="line">                    calendar = Calendar.getInstance();</span><br><span class="line">                    int year = calendar.get(Calendar.YEAR);</span><br><span class="line">                    DebugLogger.d(TAG, &quot;没处理的网络时间：&quot;+new Date(uc.getDate()));</span><br><span class="line">                    calendar.setTimeInMillis(uc.getDate());</span><br><span class="line">                    // 百度是GMT 0:00时区，需要转到GMT +8:00时区</span><br><span class="line">                    calendar.setTimeZone(new SimpleTimeZone(8, &quot;GMT&quot;));</span><br><span class="line">                    data = calendar.getTimeInMillis();</span><br><span class="line">                    DebugLogger.d(TAG, &quot;得到的网络时间：&quot;+new Date(calendar.getTimeInMillis()).toString());</span><br><span class="line">                    DebugLogger.d(TAG, &quot;得到的系统时间：&quot;+new Date(Calendar.getInstance().getTimeInMillis()));</span><br><span class="line">                    // 年份相同直接停止</span><br><span class="line">                    if (year == calendar.get(Calendar.YEAR))&#123;</span><br><span class="line">                        DebugLogger.d(TAG,&quot;系统的网络校时成功或者已经校对过时间了&quot;);</span><br><span class="line">                        stopSelf();</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyyMMdd.HHmmss&quot;);</span><br><span class="line">                    Date date = new Date(data);</span><br><span class="line">                    String format = simpleDateFormat.format(date);</span><br><span class="line">                    String shellString = &quot;date -s &quot; +format;</span><br><span class="line">                    // 设置时区，只能是这个问题了，这个很快就闪过去了，暂时没找到合适的原因</span><br><span class="line">                    shellString += &quot;&amp;&amp; setprop persist.sys.timezone \&quot;Asia/Shanghai\&quot;&quot;;</span><br><span class="line">                    RootCmd.execRootCmd(shellString);</span><br><span class="line">                    DebugLogger.d(TAG,&quot;网络校时成功&quot;);</span><br><span class="line">                    DebugLogger.d(TAG, &quot;执行的shell命令：&quot;+shellString);</span><br><span class="line">                    DebugLogger.d(TAG,&quot;校时过后的时区：&quot;+ TimeZone.getDefault().getDisplayName());</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    DebugLogger.d(&quot;SyncTimeService&quot;,&quot;网络校时失败&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0,5000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        if (mTimer != null)&#123;</span><br><span class="line">            mTimer.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般都是系统校时快于我们手动执行校时。<br>参考</p>
<p><a href="https://blog.csdn.net/firedancer0089/article/details/59526369" target="_blank" rel="noopener">https://blog.csdn.net/firedancer0089/article/details/59526369</a></p>
</div><div class="tags"><a href="/tags/Android/">Android</a></div><div class="post-nav"><a class="next" href="/2018/08/03/IoT_deploy/">IoT部署相关</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android系统/">Android系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/嵌入式/" style="font-size: 15px;">嵌入式</a> <a href="/tags/月记/" style="font-size: 15px;">月记</a> <a href="/tags/Context/" style="font-size: 15px;">Context</a> <a href="/tags/Android原理/" style="font-size: 15px;">Android原理</a> <a href="/tags/硬件/" style="font-size: 15px;">硬件</a> <a href="/tags/Ionic/" style="font-size: 15px;">Ionic</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/VLC/" style="font-size: 15px;">VLC</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/折腾/" style="font-size: 15px;">折腾</a> <a href="/tags/flex/" style="font-size: 15px;">flex</a> <a href="/tags/感悟/" style="font-size: 15px;">感悟</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/Android校时全过程/">Android 校时全过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/03/IoT_deploy/">IoT部署相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/16/年末了/">年末了</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/13/事件分发机制/">事件分发机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/Android消息机制/">Android消息机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/比分更新功能记录/">比分更新功能记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Handler使用的使用/">Handler使用，内存泄漏的前前后后</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/常用的git命令/">常用的git命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/Android进程线程和内存/">Android进程/线程和内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/引子/">引子</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">JsonMi.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>